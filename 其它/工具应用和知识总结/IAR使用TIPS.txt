1. 可以调试器配合IAR进行仿真调试；
	例如MSP-FET 430UIF

2. 在IAR DEBUG模式下，可以直接调用printf进行打印，打印信息将显示在IAR的Terminal I/O窗口中；
	相关设置：options ->general options->library Configuration选择library为FULL DLIB，会导致使用的内存显著加大
									   为Normal DLIB，内存会略小，但是打印速度很慢；
	在进行打印时，芯片无法响应中断；

3. IAR for430时：
	general options->Stack/Heap中的选项Data16_heap表示堆大小；其只有在调用了malloc后才会进行分配，否则不分配。

4. IAR for430 RAM分配时默认使用2字节对齐；

5.  字节对齐

计算机主要的架构就分为两类，复杂指令集计算机（CISC）和精简指令集计算机（RISC）。
CISC最有代表性的架构就是x86，RISC最有代表性的架构就是ARM。不管是什么架构，
对要访问的一定长度的数据的地址是有要求的，比如要访问一个32位的整数，那么这个数据必须（最好）存储在以4字节（32/8=4）对齐的地方。
一般来说，RISC对对齐要求的更严格些，非对齐访问可能会带来性能上的损失。
这对程序在不同架构间移植非常重要，因为它极有可能导致你的程序崩溃


对齐命令：#pragma pack(n) #pragma pack() n可以取1,2,4,8,16
	__packed指示是否允许非对齐；

    一旦使用pack(1)进行对齐后，有些2字节的数据或者4字节的数据起始地址就有可能在非对齐地址上。

	MSP430编译器：	
	   对相关数据只能按字节进行存取访问。
   	   如果在奇地址上进行2字节的访问，IAR编译器不会提示出错，有可能会进行警告；且编译器不会自动进行修正，导致访问出错。
   	   所以非对齐方式进行存取访问会出错。

	ARM：
		在栈上定义的变量必须是对齐访问；在堆上则可进行非对齐访问；也许是因为ARM可自动进行修正；

                实际是在使用pack(1)后，可以直接访问结构体的成员；
                不能先将结构体的成员地址转成其它指针，再转成结构体成员类型的指针并访问此成员，结果肯定出错。

6. IAR for430如果结构体不使用pack(1)，但是结构体的某个结构体成员使用pack(1)，会出现结构体数据赋值紊乱。
	具体需要参考汇编进行分析；有可能是编译器的bug；
	
